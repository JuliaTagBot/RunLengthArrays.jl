var documenterSearchIndex = {"docs":
[{"location":"#RunLengthArrays.jl-1","page":"Home","title":"RunLengthArrays.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This small Julia package implements a new type, RunLengthArray{N,T}, that efficiently encodes an array containing long sequences of repeated values, like the following example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"6 6 6 6 4 4 4 4 4 4 4 10 10 10 10 10 10 …","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The RunLengthArray{N,T} type uses a run-length encoding algorithm.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following program shows its usage:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"original = Int64[3, 3, 3, 7, 7, 7, 7];\ncompressed = CMBSim.RunLengthArray{Int,Int64}(original);\n\nfor elem in compressed:\n    println(elem)\nend\n\nprintln(\"The sum of the elements is \", sum(compressed))\nprintln(\"The 3rd element is \", compressed[3])\n\npush!(compressed, 7)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The type RunLengthArray derives from AbstractArray.","category":"page"},{"location":"#Creating-an-array-1","page":"Home","title":"Creating an array","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can create an instance of RunLengthArray{N,T} using one of its three constructors:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can call the constructor without parameters; in this case, the array will be empty. You can fill it later using push! and append!.\nYou can pass an array, which will be compressed;\nYou can pass two arrays, containing the length and value of each run respectively.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The types N and T encode the types of the counter and of the value, respectively.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The third constructor is the most interesting. Suppose that you want to store a sequence containing four instances of the number 4.6, followed by five instances of the number 5.7:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"4.6 4.6 4.6 4.6   5.7 5.7 5.7 5.7 5.7","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can achieve this result using one of the two following forms:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Second constructor\nx = RunLengthArray{Int,Float64}([4.6, 4.6, 4.6, 4.6, 5.7, 5.7, 5.7, 5.7, 5.7])\n\n# Third constructor (preferred in this case)\ny = RunLengthArray{Int,Float64}([4, 5], [4.6, 5.7])","category":"page"},{"location":"#Operations-on-run-length-arrays-1","page":"Home","title":"Operations on run-length arrays","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package defines specialized versions of a few functions in Julia's library, in order to make them more efficient. Here is a list of them:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"sum\nminimum\nmaximum\nextrema\nsort\nsort!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Calling this functions to run-length arrays can be significantly faster. Here is an example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> compr = RunLengthArray{Int, Float64}([100000, 200000], [1.1, 6.6]);\n\njulia> uncompr = collect(compr);\n\njulia> @benchmark minimum(compr)\nBenchmarkTools.Trial: \n  memory estimate:  16 bytes\n  allocs estimate:  1\n  --------------\n  minimum time:     37.372 ns (0.00% GC)\n  median time:      39.660 ns (0.00% GC)\n  mean time:        48.777 ns (14.87% GC)\n  maximum time:     52.816 μs (99.91% GC)\n  --------------\n  samples:          10000\n  evals/sample:     992\n\njulia> @benchmark minimum(uncompr)\nBenchmarkTools.Trial: \n  memory estimate:  16 bytes\n  allocs estimate:  1\n  --------------\n  minimum time:     751.926 μs (0.00% GC)\n  median time:      776.371 μs (0.00% GC)\n  mean time:        788.463 μs (0.00% GC)\n  maximum time:     1.094 ms (0.00% GC)\n  --------------\n  samples:          6326\n  evals/sample:     1","category":"page"},{"location":"#Modifying-run-length-arrays-1","page":"Home","title":"Modifying run-length arrays","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There are only three operations that can modify a run-length array:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"push! (add an element or a run to the end of the array);\nappend! (add a sequence to the end of the array);\nsort! (sort the array in-place).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The push! function can be used in two ways:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Passing one value of type T will append it to the end of the array;\nPassing a tuple with type Tuple{N,T} will append a run to the end of the array.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here is an example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"x = RunLengthArray{Int, Float64}()\npush!(x, (4, 1.1))\npush!(x, (6, 2.2))\n\n# The above array is equal to the following:\ny = RunLengthArray{Int, Float64}([4, 6], [1.1, 2.2])","category":"page"},{"location":"#API-documentation-1","page":"Home","title":"API documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [RunLengthArrays]","category":"page"},{"location":"#RunLengthArrays.RunLengthArray","page":"Home","title":"RunLengthArrays.RunLengthArray","text":"An array of objects of type T encoded using run-length compression.\n\nThis works like an array, but it is designed to be extremely efficient when the array is long and consists of long repetitions («runs») of the same elements. The length of each run is held using type N; this type should be chosen according to the expected maximum length of a run.\n\nOnce a RunLengthArray has been created, new elements can be added only at the end of it, using push! (add one element) or append! (add a sequence of elements).\n\narr = RunLengthArray{Int, Int8}(Int8[3, 3, 3, 7, 7, 7, 7, 7, 7, 4])\n\nlongarr = collect(arr)\n\n@assert length(arr) == 10\n@assert sum(arr) == 30\n@assert arr[1] == 3\n@assert arr[2] == 3\n\nprintln(\"$(sizeof(arr))\")  # Prints 16 (bytes)\nprintln(\"$(sizeof(longarr))\")  # Prints 56 (bytes)\n\n\n\n\n\n","category":"type"},{"location":"#Base.append!-Union{Tuple{T}, Tuple{N}, Tuple{RunLengthArray{N,T},Any}} where T where N","page":"Home","title":"Base.append!","text":"append!(arr::RunLengthArray{N,T}, otherarray)\n\nAppend an array to a RunLengthArray, modifying it in place.\n\n\n\n\n\n","category":"method"},{"location":"#Base.push!","page":"Home","title":"Base.push!","text":"push!(arr::RunLengthArray{N,T}, newval::T) where {N <: Number,T}\npush!(arr::RunLengthArray{N,T}, newrun::Tuple{N,T}) where {N <: Number,T}\n\nAppend a element or a run of elements to the end of a RunLengthArray. In the second case, the parameter newrun must be a tuple containing the number of repetitions n and the value v: (n, v).\n\narr = RunLengthArray{Int, Float64}([3, 2], [1.1, 6.5])\n@assert length(arr) == 5\n\n# Add 6 instances of the number \"1.4\" at the end of the array\npush!(arr, (6, 1.4))\n\n@assert length(arr) == 11\nBase.push!\n\n`\n\n\n\n\n\n","category":"function"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"}]
}
